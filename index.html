const { Telegraf } = require('telegraf');
const dotenv = require('dotenv'); dotenv.config();
const fs = require('fs');
const path = require('path');
const nodemailer = require('nodemailer');
const { createEvent } = require('ics');
const { google } = require('googleapis');

const bot = new Telegraf(process.env.BOT_TOKEN);

// --- старт: кнопка открытия мини-аппа
bot.start((ctx) => {
  ctx.reply('Открой мини-приложение Roomie+', {
    reply_markup: {
      inline_keyboard: [[
        { text: 'Открыть Roomie+', web_app: { url: process.env.WEBAPP_URL } }
      ]]
    }
  });
});

// --- приём данных из мини-аппа
bot.on('message', async (ctx) => {
  const data = ctx.message.web_app_data?.data;
  if (!data) return;
  let payload;
  try { payload = JSON.parse(data); } catch { return; }

  if (payload.type === 'booking_created' || payload.type === 'sync_calendar') {
    const list = payload.data || payload.bookings || [];
    if (!list.length) return;

    // 1) локальный JSON (на всякий)
    const file = path.join(__dirname, 'bookings.json');
    let arr = [];
    try { arr = JSON.parse(fs.readFileSync(file, 'utf8')); } catch {}
    arr.push(...list);
    fs.writeFileSync(file, JSON.stringify(arr, null, 2));

    // 2) почта/Exchange — отправим .ics каждому событию
    if (process.env.SMTP_HOST && process.env.MAIL_TO) {
      try {
        const transporter = nodemailer.createTransport({
          host: process.env.SMTP_HOST,
          port: Number(process.env.SMTP_PORT || 587),
          secure: process.env.SMTP_SECURE === 'true',
          auth: (process.env.SMTP_USER && process.env.SMTP_PASS) ? {
            user: process.env.SMTP_USER, pass: process.env.SMTP_PASS
          } : undefined
        });

        for (const b of list) {
          const [y,mo,d] = b.date.split('-').map(Number);
          const [sh,sm] = b.start.split(':').map(Number);
          const [eh,em] = b.end.split(':').map(Number);
          const ics = await new Promise((res, rej) => {
            createEvent({
              start: [y, mo, d, sh, sm],
              end:   [y, mo, d, eh, em],
              title: b.title || 'Встреча',
              description: `Переговорная: ${b.roomId || ''}`,
              uid: (b.id || Date.now()) + '@roomie',
              status: 'CONFIRMED'
            }, (err, value) => err ? rej(err) : res(value));
          });

          await transporter.sendMail({
            from: process.env.SMTP_USER || 'roomie@localhost',
            to: process.env.MAIL_TO,
            subject: `Бронь: ${b.title} (${b.start}–${b.end})`,
            text: `Дата: ${b.date}\nВремя: ${b.start}–${b.end}\nКомната: ${b.roomId}`,
            alternatives: [{ contentType: 'text/calendar; charset="utf-8"; method=REQUEST', content: ics }],
            icalEvent: { filename: 'invite.ics', content: ics }
          });
        }
      } catch (e) {
        console.error('SMTP error:', e.message);
      }
    }

    // 3) Google Calendar (если заданы переменные)
    if (process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL && process.env.GOOGLE_SERVICE_ACCOUNT_PRIVATE_KEY) {
      try {
        const jwt = new google.auth.JWT(
          process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
          undefined,
          process.env.GOOGLE_SERVICE_ACCOUNT_PRIVATE_KEY.replace(/\\n/g, '\n'),
          ['https://www.googleapis.com/auth/calendar']
        );
        const calendar = google.calendar({ version: 'v3', auth: jwt });
        for (const b of list) {
          const isoStart = `${b.date}T${b.start}:00`;
          const isoEnd   = `${b.date}T${b.end}:00`;
          await calendar.events.insert({
            calendarId: process.env.GOOGLE_CALENDAR_ID || 'primary',
            requestBody: {
              summary: b.title || 'Встреча',
              description: `Переговорная: ${b.roomId || ''}`,
              start: { dateTime: isoStart },
              end:   { dateTime: isoEnd }
            }
          });
        }
      } catch (e) {
        console.error('Google error:', e.message);
      }
    }

    await ctx.reply(`Синхронизировано: ${list.length} броней ✅`);
  }
});

bot.launch().then(()=>console.log('Bot started'));
